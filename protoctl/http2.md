# http2

- [http2](#http2)
  - [http1.1所遇到的问题](#http11所遇到的问题)
    - [1.高延迟带来页面加载速度的降低](#1高延迟带来页面加载速度的降低)
    - [2. 无状态特性带来的巨大的HTTP头部](#2-无状态特性带来的巨大的http头部)
    - [3. 无法被动感知服务器状态变更](#3-无法被动感知服务器状态变更)
  - [http2概述](#http2概述)
    - [http2特性](#http2特性)

## http1.1所遇到的问题

### 1.高延迟带来页面加载速度的降低

网络带宽大幅提高之后，而延迟水平并没有大幅度的提高。主要有两个问题到导致：

* 物理距离的不可避免，例如一台在太平洋一端的服务器，另一端访问，物理延迟就高达200ms
* 最后一公里人问题，数据在到达客户端之前，经过太多交换机路由器设备，出现排队等待现象

另外http1.1本身的限制，加剧了这种现象。首先浏览器同时并发的连接数是有限的，(chrome)浏览器只支持6个，**同一个TCP连接同时只能允许一个HTTP事务完成**才能开始下一个事务。

### 2. 无状态特性带来的巨大的HTTP头部

应为HTPP遵循`REST`架构特性，每一个请求都要求是无状态的，每次请求/响应都必须带上巨大的头部。特别是`Cookie`这样头部。

### 3. 无法被动感知服务器状态变更

基于断连的http1.1，`请求/响应`模式下，只能通过轮询的方式，获取到服务端的变更。或者增加`websocket`作为补充协议的方式，实现服务器对浏览器的通知。

## http2概述

`http2`协议的前身是谷歌支持的`SPDY`协议，后续谷歌为支持`http2`协议，放弃了对`SPDY`的支持，定义在`RFC7540`中。

`http2`做出的修改：

* 在应用层上做出修改，并充分挖掘TCP协议性能
* `请求/响应`基本模型不变
* `scheme`不改变，还是使用`http://`，没有特定`http2://`
* `http1.x`协议的客户端和服务器可以无缝通过代理方式转接到http/2上
* 不能识别`http2`协议的代理服务器可以将请求降级到http1.x上
* `http2`支持多路复用，http事务不用在TCP连接上串行执行

### http2特性

* 传输数据量大幅减少
    - 以二进制方式传输(http1使用ASCII码传输)
    - 标头压缩
* 多路复用以及相关功能
    - 消息优先级
* 服务器消息推送
    - 并行推送

`http2`协议既可以基于`TCP`协议，也可以在`TLS`协议之上。然而在浏览器中，强制要求基于`TLS`协议，实现`http2`协议
