# 面试题

- [面试题](#面试题)
  - [golang](#golang)
    - [1.1 `go channel close` 之后，读的问题?](#11-go-channel-close-之后读的问题)
    - [1.2 `go slice` 和 `array` 的区别？](#12-go-slice-和-array-的区别)
    - [1.3 GMP原理？](#13-gmp原理)
    - [1.4 `singleflight`源码刨析？](#14-singleflight源码刨析)
    - [1.5 sync.WaitGroup原理？](#15-syncwaitgroup原理)
    - [1.6 go的调度？](#16-go的调度)
    - [1.7 `struct`能不能比较？](#17-struct能不能比较)
    - [1.8 `select`用途？](#18-select用途)
    - [1.9 `context`用途？](#19-context用途)
  - [网络](#网络)
  - [计算机原理](#计算机原理)

## golang

### 1.1 `go channel close` 之后，读的问题?

* 无缓存`channel`，读和写都会触发`panic`
* 有缓存的`channel`，写直接`panic`，而读则是可以读完缓存中剩余的数据，读玩之后，再读就是0值

### 1.2 `go slice` 和 `array` 的区别？

* array是一个固定大小的内存区块，所以分配和内容是固定，也就意味着不可修改
* slice可以理解为动态数组，由***指针***，***长度***，和***容量组成***

切片扩容方式：
  - 新增请容量是否大于2倍旧容量，是，则新申请容量就是最终容量
  - 否，则旧容量小于1024，则最终容量就是2倍旧容量
  - 如果旧容量大于等于1024，则循环增加1/4，直到大于新申请容量
  - 如果最终容量计算值溢出，则最终容量就是新申请容量

### 1.3 GMP原理？

### 1.4 `singleflight`源码刨析？

`singleflight`包是`golang.org/x`拓展包，调用

```
import "golang.org/x/sync/singleflight"
```

内部机制其实是依赖waitGroup，控制请求访问资源时，可能被击穿的情况。

### 1.5 sync.WaitGroup原理？

### 1.6 go的调度？

### 1.7 `struct`能不能比较？

### 1.8 `select`用途？

### 1.9 `context`用途？

## 网络

## 计算机原理