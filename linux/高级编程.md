# Linux环境高级编程

- [Linux环境高级编程](#linux环境高级编程)
  - [线程](#线程)
    - [线程的生命周期](#线程的生命周期)
      - [线程ID](#线程id)
      - [线程创建](#线程创建)
      - [线程终止](#线程终止)
      - [线程优雅退出](#线程优雅退出)
    - [线程控制](#线程控制)
      - [线程属性](#线程属性)
      - [互斥量](#互斥量)
      - [信号量](#信号量)

## 线程

**线程** 是程序执行的最小单元。每个线程，都含有执行环境所必须的信息。包括线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量，以及线程私有变量。一个进程内所有信息都是对该进程的所有线程是共享的，包括全部内存和堆内存，栈，以及文件描述符。

在`Linux`中，线程接口被称之为`pthread`，对应的是`<pthread.h>`头文件，需要注意的是，`gcc/g++`编译时，需要`-lpthread`链接。

### 线程的生命周期

#### 线程ID

```c
#include<pthread.h>

pthread_t pthread_self(void);  // 获取线程ID,（pthread_t）类型

int pthread_equal(pthread_t tid1, pthread_t tid2); // 判断两个线程ID是否相等， 若相等，返回非0
```

#### 线程创建

```c
#include<pthread.h>

int pthread_create(pthread_t *restrict tidp,
    const pthread_attr_t *restrict attr,
    void *(*start_rtn)(void *), void *restrict arg);

// 成功创建，返回0， 否返回错误编号
```

* tiap: 是成功创建时，返回线程ID（pthread_t*）
* attr：用于定制各种不同的线程属性，参见[线程属性](#线程属性)
* start_rtn: 线程的执行函数，必须是`void* func(void* args)`类型
* arg: 是start_rtn函数，的参数列表地址，可以用来为函数定义传入参数

**传递参数实例**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

struct Info {
    int a1;
    int a2;
};

void* thrad_func(void* args)
{
    printf("thrad_func...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2); 
}


int main()
{
    int err;
    pthread_t tid;

    struct Info info;
    info.a1 = 100;
    info.a2 = 120;
    

    err = pthread_create(&tid, NULL, thrad_func, &info);

    if (err != 0)
        printf("errno: %d\n", err);
    sleep(1);
    return 0;
}
```

#### 线程终止

如何任何线程中，调用`exit`, `_Exit`，`_exit`；则整个进程都会终止。单个线程可以在下面三种方法中，不退出进程的情况下，停止它的控制流:

1. 线程可以简单的从启动函数中返回，返回值就是线程的退出码
2. 线程可以被同一进程的其他线程取消
3. 线程调用pthread_exit

```c
#include <pthread.h>

void pthread_exit(void* rval_ptr);
```

`rval_ptr`是一个无类型的指针，用来传递返回结果。其他线程可以通过`pthread_join`函数访问到这个指针

```c
#include <pthread.h>

int pthread_join(pthread_t tid, void** rval_ptr);
```

`pthread_join`一旦调用，调用线程就处于阻塞状态。直到调用的线程返回，或者取消。调用`pthread_join`会使线程处于**分离状态**，如果线程已经处于**分离状态**，则会调用失败。`pthread_join`函数可以等待指定的线程终止，但并不是获取线程的终止状态。

**线程exit实例**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

struct Info {
    int a1;
    int a2;
};

void* thread_func1(void* args)
{
    printf("thrad_func1...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2); 
    return ((void*)1);
}

void* thread_func2(void* args)
{
    printf("thrad_func2...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2);
    pthread_exit((void*)2);
}


int main()
{
    int err;
    pthread_t tid1, tid2;
    void* tret;

    struct Info info1;
    info1.a1 = 100;
    info1.a2 = 120;

    struct Info info2;
    info2.a1 = 200;
    info2.a2 = 220;


    err = pthread_create(&tid1, NULL,thread_func1, &info1);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }

    err = pthread_create(&tid2, NULL, thread_func2, &info2);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }

    err = pthread_join(tid1, &tret);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }
    printf("thread1 tret: %ld\n", (long) tret);

    err = pthread_join(tid2, &tret);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }
    printf("thread2 tret: %ld\n", (long) tret);
    
    sleep(1);
    return 0;
}
```

> 注意: `pthread_create`和`pthread_exit`中的，无类型指针参数传递的值，必须是调用者调用之后，依旧是有效的，注意内存的栈空间覆盖问题。

#### 线程优雅退出

线程可以调用`pthread_cancel`函数，请求取消同一进程中的其他线程。

```c
#include <pthread.h>

int pthread_cancel(pthread_t tid);

// 若成功返回0， 否则返回错误编号
```

`pthread_cancnel`并不会等待线程的终止，仅仅是提出请求。其本质上是，调用了参数`PTHREAD_CANCELED`的`pthread_exit`函数。但线程可以忽略取消。

线程同时可以设定退出时的清理函数：

```c
#include <pthread.h>

void pthread_cleanup_push(void (*rtn)(void *), void *arg);  // push 清理函数
void pthread_cleanup_pop(int execute);  // 移除清理函数
```

### 线程控制

#### 线程属性

#### 互斥量

#### 信号量