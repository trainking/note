# Linux环境高级编程

- [Linux环境高级编程](#linux环境高级编程)
  - [线程](#线程)
    - [线程的生命周期](#线程的生命周期)
      - [线程ID](#线程id)
      - [线程创建](#线程创建)
      - [线程终止](#线程终止)
      - [线程优雅退出](#线程优雅退出)
    - [线程控制](#线程控制)
      - [线程属性](#线程属性)
      - [互斥量](#互斥量)
        - [属性](#属性)
      - [信号量](#信号量)

## 线程

**线程** 是程序执行的最小单元。每个线程，都含有执行环境所必须的信息。包括线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量，以及线程私有变量。一个进程内所有信息都是对该进程的所有线程是共享的，包括全部内存和堆内存，栈，以及文件描述符。

在`Linux`中，线程接口被称之为`pthread`，对应的是`<pthread.h>`头文件，需要注意的是，`gcc/g++`编译时，需要`-lpthread`链接。

### 线程的生命周期

#### 线程ID

```c
#include<pthread.h>

pthread_t pthread_self(void);  // 获取线程ID,（pthread_t）类型

int pthread_equal(pthread_t tid1, pthread_t tid2); // 判断两个线程ID是否相等， 若相等，返回非0
```

#### 线程创建

```c
#include<pthread.h>

int pthread_create(pthread_t *restrict tidp,
    const pthread_attr_t *restrict attr,
    void *(*start_rtn)(void *), void *restrict arg);

// 成功创建，返回0， 否返回错误编号
```

* tiap: 是成功创建时，返回线程ID（pthread_t*）
* attr：用于定制各种不同的线程属性，参见[线程属性](#线程属性)
* start_rtn: 线程的执行函数，必须是`void* func(void* args)`类型
* arg: 是start_rtn函数，的参数列表地址，可以用来为函数定义传入参数

**传递参数实例**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

struct Info {
    int a1;
    int a2;
};

void* thrad_func(void* args)
{
    printf("thrad_func...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2); 
}


int main()
{
    int err;
    pthread_t tid;

    struct Info info;
    info.a1 = 100;
    info.a2 = 120;
    

    err = pthread_create(&tid, NULL, thrad_func, &info);

    if (err != 0)
        printf("errno: %d\n", err);
    sleep(1);
    return 0;
}
```

#### 线程终止

如何任何线程中，调用`exit`, `_Exit`，`_exit`；则整个进程都会终止。单个线程可以在下面三种方法中，不退出进程的情况下，停止它的控制流:

1. 线程可以简单的从启动函数中返回，返回值就是线程的退出码
2. 线程可以被同一进程的其他线程取消
3. 线程调用pthread_exit

```c
#include <pthread.h>

void pthread_exit(void* rval_ptr);
```

`rval_ptr`是一个无类型的指针，用来传递返回结果。其他线程可以通过`pthread_join`函数访问到这个指针

```c
#include <pthread.h>

int pthread_join(pthread_t tid, void** rval_ptr);
```

`pthread_join`一旦调用，调用线程就处于阻塞状态。直到调用的线程返回，或者取消。调用`pthread_join`会使线程处于**分离状态**，如果线程已经处于**分离状态**，则会调用失败。`pthread_join`函数可以等待指定的线程终止，但并不是获取线程的终止状态。

**线程exit实例**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

struct Info {
    int a1;
    int a2;
};

void* thread_func1(void* args)
{
    printf("thrad_func1...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2); 
    return ((void*)1);
}

void* thread_func2(void* args)
{
    printf("thrad_func2...\n");
    struct Info* _args = (struct Info*)args;
    printf("info a1: %d, a2: %d\n", _args->a1, _args->a2);
    pthread_exit((void*)2);
}


int main()
{
    int err;
    pthread_t tid1, tid2;
    void* tret;

    struct Info info1;
    info1.a1 = 100;
    info1.a2 = 120;

    struct Info info2;
    info2.a1 = 200;
    info2.a2 = 220;


    err = pthread_create(&tid1, NULL,thread_func1, &info1);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }

    err = pthread_create(&tid2, NULL, thread_func2, &info2);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }

    err = pthread_join(tid1, &tret);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }
    printf("thread1 tret: %ld\n", (long) tret);

    err = pthread_join(tid2, &tret);
    if (err != 0)
    {
        printf("errno: %d\n", err);
        return 0;
    }
    printf("thread2 tret: %ld\n", (long) tret);
    
    sleep(1);
    return 0;
}
```

> 注意: `pthread_create`和`pthread_exit`中的，无类型指针参数传递的值，必须是调用者调用之后，依旧是有效的，注意内存的栈空间覆盖问题。

#### 线程优雅退出

线程可以调用`pthread_cancel`函数，请求取消同一进程中的其他线程。

```c
#include <pthread.h>

int pthread_cancel(pthread_t tid);

// 若成功返回0， 否则返回错误编号
```

`pthread_cancnel`并不会等待线程的终止，仅仅是提出请求。其本质上是，调用了参数`PTHREAD_CANCELED`的`pthread_exit`函数。但线程可以忽略取消。

线程同时可以设定退出时的清理函数：

```c
#include <pthread.h>

void pthread_cleanup_push(void (*rtn)(void *), void *arg);  // push 清理函数
void pthread_cleanup_pop(int execute);  // 移除清理函数
```

在默认情况下，线程的终止状态会保持到对该线程进行`pthread_join`，如果该线程已经被分离，该线程的底层资源可以在终止时，立刻回收。可以使用`pthread_detach`函数分离线程：

```c
#include <pthread.h>

int pthread_detach(pthread_t tid);
```

### 线程控制

#### 线程属性

#### 互斥量

互斥量本质上是一把排他锁，通过加锁的形式控制线程对资源的读写，解决数据冲突。`Linux`中的互斥量是`pthread_mutex_t`数据类型的，有两种可以初始化的方式：

1. 使用`PTHREAD_MUTEX_INITIALIZE`常量对变量赋值，只适用于静态分配的互斥量
2. 使用`pthread_mutex_init`进行初始化

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);   // 初始化互斥量

int pthread_mutex_destroy(pthread_mutex_t *mutex);  // 销毁互斥量
```

> 销毁互斥量时，需注意：无需销毁`PTHREAD_MUTEX_INITIALIZE`常量创建的互斥体。不要销毁一个已经加锁和正在被条件变量使用的互斥体，会返回`EBUSY`错误。

通常情况下，互斥量属性`attr`被设置为NULL，其他详见[属性](#属性)。

```c
#include<pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);  // 加锁，无法获得锁，阻塞

int pthread_mutex_trylock(pthread_mutex_t *mutex); // 尝试锁，不阻塞

int pthread_mutex_unlock(pthread_mutex_t *mutex); // 解锁

// 成功返回0，失败返回编号
```

**实例：保证序号**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

typedef struct _student
{
    int age;
    pthread_mutex_t mutex;
} Student;

Student *stu_alloc(int age)
{
    Student *stu;
    if ((stu = malloc(sizeof(Student))) != NULL)
    {
        stu->age = age;
        if (pthread_mutex_init(&stu->mutex, NULL) != 0)
        {
            free(stu);
            return (NULL);
        }
    }
    return stu;
}

void stu_zd(Student *stu)
{
    pthread_mutex_lock(&stu->mutex);
    stu->age++;
    printf("zd: %d\n", stu->age);
    pthread_mutex_unlock(&stu->mutex);
}

void *thread_func(void *args)
{
    Student *stu = (Student *)args;
    stu_zd(stu);
    return (void *)0;
}

int main()
{
    Student *stu;
    stu = stu_alloc(0);

    for (int i = 0; i < 3; ++i)
    {
        pthread_t tid;
        pthread_create(&tid, NULL, thread_func, stu);
        printf("tid: %ld\n", (long) tid);
    }
    sleep(10);
    return 0;
}
```


##### 属性


#### 信号量