# 状态同步服务器

## 0x01 概述

### 什么是状态

**状态**是指游戏中，某个时刻，某个对象所处的一系列描述它状态的参数集合。所以状态同步，便是同步这一个状态集合。而往往设计一个状态同步服务器时，意味着服务器需要做到：

1. 保存一份整局游戏的世界快照（全局所有状态）
2. 需要实现一个游戏模拟器，模拟客户端输入，变更状态

#### 什么是指令

**指令**是指玩家操作的抽象，例如玩家向前移动，使用了技能，进行了跳跃。都是一个玩家的指令，简而言之就是**玩家主动干了啥**。

#### 状态同步模式

从实现上来说，状态同步服务器，可以有两种实现：**状态-状态同步，服务端校验**，**指令-状态同步，前端预测回滚**。在实际实现中，有些不好计算，然后又不是太紧要的状态，可以交给客户端计算，然后传输给服务端校验即可。但，简化模型就是：

```
C->S: 发送指令到客户端
S: 服务端根据指令模拟出状态
S->C：同步状态给客户端，客户端重置玩家状态（预测回滚）
```

## 0x02 技术实现

### 客户端设计

首先，我们要将玩家可以进行的操作，抽象一个各个指令，抽象出来的结构，我们可以称之为**指令帧**。每个指令表达的是，玩家进行的一次操作，同时我们需要注意，真实玩家并不是可以无限发送指令的，例如人类的手速极限，也就是12按键/秒，因此我们可以发送指令的间隔，可以冗余到15帧/每秒。

一个标准的指令结构如下：

```protobuf
message GameInput {
    int64 Seq = 1;  // 指令操作的序号，用于预测回归，服务器同步时，将执行的序号返回给客户端
    float InputX = 2;  // 位移操作X坐标
    float InputY = 3;  // 位移操作Y坐标
    int32 SkillId = 4;  // 释放的技能
}
```

#### 为什么指令需要定期发送指令？

因为重复发送过多指令，会让服务器端的网关不堪重负，而且玩家的操作不可能太过迅速，所以一般玩家指令，66毫秒一次发送（15帧/每秒），就可以了。

### 服务端设计

服务端的步骤如下：

1. 服务端必须将接收到的指令，按照seq排序存好。
2. 服务端定时开启模拟，从指令队列中，取出指令进行处理。
3. 服务端模拟出状态结果，通过同步帧方式发送给客户端。

其中，服务端的游戏状态，我们一般称之为**世界快照**，这时一份动态改变的内存数据。它需要通过，服务端模拟**游戏玩法**来生成，这个过程可以看作一个函数，**指令是它的输入，玩法模拟是函数体，世界快照是输出结果**。

```
玩法(指令) 世界快照
```

#### 为什么模拟需要定时执行？

1. 需要等待不同延迟的玩家，发送的数据到达，避免错位模拟，造成有的玩家，总是卡顿
2. 玩法模拟也是一个很吃服务器资源的操作，所以通过定时执行，将一批指令，统一处理

## 0x03 优缺点

### 优点

1. 为状态在服务端生成，可以减少外挂的产生
2. 可以保护关键的数据
3. 客户端开发逻辑相对简单，回滚时只需要用服务端数据覆盖，优化主要集中在**预测和掩饰**
4. 不会有浮点数问题

### 缺点

1. 服务端负载很高
2. 服务端开发难度表达，很多时候做法，是客户端开发好玩法，交给服务端执行